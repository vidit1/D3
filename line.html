<!DOCTYPE html>
<meta charset="utf-8">
<style>

    body {
        font: 10px sans-serif;
    }

    .axis path,
    .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;

    }

    .y path {
        display: none;
    }

    .y > .tick line,
    .x > .tick line,
    .x > path
    {
        opacity: 0.18 !important;
    }

    .axis-label{
        font-size: 12px;
    }
    .line {
        fill: none;
        stroke: steelblue;
        stroke-width: 2px;
    }

    .line-hover {
        stroke-width: 4px;
    }

    .resetZoom{

        background-color: grey;
    }
    .toggleReset {
        display: none !important;
    }
    #test {
        border: 2px solid black;
    }

    .legend .series {
        cursor: pointer;
    }

    .legend circle {
        stroke-width: 2px;
        fill-opacity: 0;
    }

    .legend .disabled circle {
        fill-opacity: 2;
    }

    div.tooltip {
        position: absolute;
        text-align: center;
        width: 60px;
        height: 28px;
        padding: 2px;
        font: 12px sans-serif;
        background: lightsteelblue;
        border: 0px;
        border-radius: 8px;
        pointer-events: none;
    }

    rect {
        fill: #8c97b4;

    }

    rect.zoom {
        fill-opacity: 0.5;
    }

    svg *::selection {
        background: transparent;
    }

    svg *::-moz-selection {
        background: transparent;
    }

    svg *::-webkit-selection {
        background: transparent;
    }

    /********************
     * TOOLTIP CSS
     */

    .nvtooltip {
        position: absolute;
        background-color: rgba(255, 255, 255, 1);
        padding: 10px;
        border: 1px solid #ddd;

        font-family: Arial;
        font-size: 13px;

        /*transition: opacity 500ms linear;*/
        /*-moz-transition: opacity 500ms linear;*/
        /*-webkit-transition: opacity 500ms linear;*/

        /*transition-delay: 500ms;*/
        /*-moz-transition-delay: 500ms;*/
        /*-webkit-transition-delay: 500ms;*/

        -moz-box-shadow: 4px 4px 12px rgba(0, 0, 0, .5);
        -webkit-box-shadow: 4px 4px 12px rgba(0, 0, 0, .5);
        box-shadow: 4px 4px 12px rgba(0, 0, 0, .5);

        -moz-border-radius: 15px;
        border-radius: 15px;
    }

    .nvtooltip h3 {
        margin: 0;
        padding: 0;
        text-align: center;
    }

    .nvtooltip p {
        margin: 0;
        padding: 0;

    }

    .nvtooltip span {
        display: inline-block;
        margin: 2px 0;
    }


</style>
<link href="https://cdnjs.cloudflare.com/ajax/libs/jquery.tipsy/1.0.3/jquery.tipsy.min.css" rel="stylesheet"
      type="text/css">
<body>
<div id="test"></div>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tipsy/1.0.3/jquery.tipsy.min.js"></script>
<script src="hammer.js"></script>
<script src="bower_components/moment/min/moment.min.js"></script>
<script src="d3.js"></script>
<script src="d3legend.js"></script>
<script src="tooltip.js"></script>
<script>

    //TODO 1. Handling no data  (done)
    //TODO 2. All the legends are unchecked display no data to display (done)
    //TODO 3. Error handling in D3 (done)
    //TODO 4. Mobile view pan functionality
    //TODO 5. Mobile view pinch functionality for zooming
    //TODO 6. While zooming through selection add additional data to the zoomed area
    //TODO 6.1 Zoom action (-->   <--) zoom in(done)
    //TODO 6.1 Zoom action (<--   -->) zoom out(done)
    //TODO 6.1 Zoom action (-->   -->) zoom in/out with left panning
    //TODO 6.1 Zoom action (<--   <--) zoom in/out with right panning
    //TODO 7. Styling for mobile view(font-size of heading, ticks and axis label increase)
    function d3Line(obj) {

        var chart = {};

        var data = obj.data;

        //Setting margin and width and height
        var margin = {top: 20, right: 30, bottom: 90, left: 50},

                width = $(obj.divId).width() - margin.left - margin.right,
                height = obj.height?obj.height:550 - margin.top - margin.bottom;

        //Parse date function
        var parseDate = d3.time.format("%Y%m%d").parse;


        //x
        var x = d3.scale.ordinal()
                .domain([0, 1])
                .rangePoints([0, width], 0.1, 0);
        //y
        var y = d3.scale.linear().range([height, margin.top]);

        var color = d3.scale.category10();

        // Defining xAxis location at bottom the axes
        var xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom")
                .tickFormat(function(d){
                    return moment(d).format("YYYY-MM-DD")
                });
        //Defining yAxis location at left the axes
        var yAxis = d3.svg.axis()
                .scale(y)
                .innerTickSize(-width)

                .orient("left");

        //graph type line and
        var line = d3.svg.line()
                .x(function (d) {
                    return x(d.date);
                })
                .y(function (d) {
                    return y(d.temperature);
                });


        //calling legend and setting width,height,margin,color
        var legend = d3Legend().height(height + margin.top + margin.bottom).width(width).margin(margin).color(color);


        var mouseMoveHide = 'visible',
                HoverFlag = true;

        //Setting domain for the colors with te exceptioon of date column
        color.domain(d3.keys(data[0]).filter(function (key) {
            return key !== "date";
        }));

        //Parsing date in the required format
        data.forEach(function (d) {
            d.date = parseDate(d.date);
        });

        //Formatting data and assigning to cities variable
        var cities = color.domain().map(function (name) {
            return {
                label: name,
                data: data.map(function (d) {
                    return {date: d.date, temperature: +d[name]};
                }),
                hover: false,
                disabled: true

            };
        });
        var rawData = JSON.parse(JSON.stringify(cities))
        var series, dataLength,zoom = true;

        //HammerJs functionality added
        var div = document.getElementById(obj.divId.indexOf("#")==-1?obj.divId:obj.divId.replace("#",""));
        var mc = new Hammer.Manager(div);
        var pinch = new Hammer.Pinch();
        var pan = new Hammer.Pan();
        var tap = new Hammer.Tap();
        var pinchFlag = false,startPointsPinch,endPointsPinch,startLocation = 0;
        pinch.recognizeWith(pan);

        mc.add([pinch, pan,tap]);

        // Prevent long press saving on mobiles.
//        div.addEventListener('touchstart', function (e) {
//            e.preventDefault()
//        });


        mc.on("panstart", function (ev) {
            if(pinchFlag==false)
                console.log("panstart",ev.center)

        });


        mc.on("panend", function (ev) {
            if(pinchFlag==false)
                console.log("panend",ev.center)

        });

        mc.on("pinchstart", function (ev) {
            pinchFlag=true;
            console.log("pinch start");
            startPointsPinch  = ev.pointers;

        });

        mc.on("pinchend", function (ev) {
            console.log("pinchend");
            endPointsPinch  = ev.pointers;
            var xpos  = parseInt(startPointsPinch[0].clientX), flag = true;
            var startFlag = startPointsPinch[0].clientX<startPointsPinch[1].clientX;
            var xPinch = [
                [//Starting info for x location
                    startFlag==true?startPointsPinch[0].clientX:startPointsPinch[1].clientX,
                    startFlag==true?startPointsPinch[1].clientX:startPointsPinch[0].clientX
                ],
                [//Ending info for x location
                    startFlag==true?endPointsPinch[0].clientX:endPointsPinch[1].clientX,
                    startFlag==true?endPointsPinch[1].clientX:endPointsPinch[0].clientX
                ]
            ];
            var yPinch = [
                [//Starting info for y location
                    startFlag==true?startPointsPinch[0].clientY:startPointsPinch[1].clientY,
                    startFlag==true?startPointsPinch[1].clientY:startPointsPinch[0].clientY
                ],
                [//Ending info for y location
                    startFlag==true?endPointsPinch[0].clientY:endPointsPinch[1].clientY,
                    startFlag==true?endPointsPinch[1].clientY:endPointsPinch[0].clientY
                ]
            ];
            console.log("Chart Name",obj.divId);
            console.log("Change index first point",parseInt(parseInt(xPinch[0][0])/(width/x.domain().length)),"-->",parseInt(parseInt(xPinch[1][0])/(width/x.domain().length)));
            console.log("Change index second point",parseInt(parseInt(xPinch[0][1])/(width/x.domain().length)),"-->",parseInt(parseInt(xPinch[1][1])/(width/x.domain().length)));
            console.log("trigger = ",
                    (parseInt(parseInt(xPinch[0][1])/(width/x.domain().length))-parseInt(parseInt(xPinch[0][0])/(width/x.domain().length)))
                    <
                    (parseInt(parseInt(xPinch[1][1])/(width/x.domain().length))-parseInt(parseInt(xPinch[1][0])/(width/x.domain().length)))?"Zoom IN":"Zoom OUT");

            var startLength =(parseInt(parseInt(xPinch[0][0])/(width/x.domain().length))-parseInt(parseInt(xPinch[1][0])/(width/x.domain().length)));
            var endLength =(parseInt(parseInt(xPinch[1][1])/(width/x.domain().length))-parseInt(parseInt(xPinch[0][1])/(width/x.domain().length)));
            console.log("points to be shifted from front",startLength);
            console.log("points to be shifted from end",endLength);
            startLocation =(startLocation + startLength)<0?0:(startLocation + startLength);
            //starting filtering data
            cities.forEach(function (d,i) {



                //slicing each line if and only if the length of data > 50 (minimum no of ticks should be present in the graph)
                    if(startLength>0&&endLength>0) {
                        console.log("pure zoom in");
                        if(d.data.length>10)
                        d.data = d.data.splice(startLength, d.data.length - endLength);
                    }

                    else if(startLength<0&&endLength<0){
                        console.log("\n")
                        console.log("\n")
                        console.log("pure zoom out");
                        console.log("Initial data length",d.data.length);
                        console.log("start location = ",(startLocation),(startLocation)<0?0:(startLocation));
                        console.log("end location   = ",(-startLength+d.data.length-endLength),rawData[i].data.length,(-startLength+d.data.length-endLength)>rawData[i].data.length,((-startLength+d.data.length-endLength)>rawData[i].data.length?rawData[i].data.length:(-startLength+d.data.length-endLength)));
                        d.data = rawData[i].data.slice((startLocation)<0?0:(startLocation),(-startLength + d.data.length-endLength)>rawData[i].data.length?rawData[i].data.length:(-startLength + d.data.length-endLength));
                        console.log("final data length",d.data.length)
                        console.log("\n");
                        console.log("\n");
                    }

                    else if(startLength<0&&endLength<0){

                    }

                    else if(startLength<0&&endLength<0){

                    }
            });
            console.log("starting index in original data=",startLocation,cities[0].data[0]);
            rawData[0].data.forEach(function (d,i) {
                if(moment(d.date).format("YYYY-MM-DD")==moment(cities[0].data[0].date).format("YYYY-MM-DD")){
                    console.log("checking data",i);
                    return;
                }
            });
            chart.plot();

            setTimeout(function () {
                pinchFlag = false;
            },500)
        });






        //chart function to create chart
        chart.plot =function () {
            //Empty the container before loading
            d3.select(obj.divId+" > *").remove();


            //Adding chart and placing chart at specific locaion using translate
            var svg = d3.select(obj.divId)
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("class", "chart")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            //Filtering data if the column is disable or not
            series = cities.filter(function (d) {
                return d.disabled;
            });
            //Appending legend box
            svg.append('g')
                    .attr('class', 'legendWrap');

            //legend location
            svg.select('.legendWrap').datum(cities)
                    .attr('transform', 'translate(' + 0 + ',' + 0 + ')')
                    .call(legend);

            //Chart Title
            svg.append('g').attr('class','titleWrap').append('text')
                    .attr("x", (width / 2))
                    .attr("y",  (margin.top / 2))
                    .attr("text-anchor", "middle")
                    .style("font-size", "20px")
                    .text(obj.title);





            //Reset Zoom Button
            svg.append('g').attr('class','resetZoom')
                    .classed("toggleReset",zoom)
                    .attr("x", 10)
                    .attr("y",  10)
                    .style("z-index",1000)
                    .append("rect")  //Appending rectangle styling
                    .attr("width",100)
                    .attr("height",25)
                    .attr("rx",2)
                    .style("fill","#f2f2f2")
                    .style("stroke","#666666")
                    .style("stroke-width","1px");

            d3.select(".resetZoom") //Adding reset zoom text to the reset zoom rectangle
                    .append("text")
                    .attr("x",10+40)
                    .attr("y",10+6)
                    .attr("text-anchor", "middle")
                    .style("font-size","12px")
                    .text("Reset Zoom");

            //Click on reset zoom function
            d3.select(".resetZoom").on("mousedown",function () {
                console.log("reset triggered");
                cities.forEach(function (d,i) {
                    d.data = rawData[i].data;
                    console.log(d);
                });
                console.log(cities);
                zoom = true;
                chart.plot()

            });

            //check if the data is present or not
            if(series.length==0 || series[0].data.length==0){
                //Chart Title
                svg.append('g').attr('class','noDataWrap').append('text')
                        .attr("x", (width / 2))
                        .attr("y",  (height / 2))
                        .attr("text-anchor", "middle")
                        .style("font-size", "20px")
                        .text("No data to display");
                return;
            }

            //storing the length of data so that the check can
            dataLength = series[0].data.length;

            //setting the upper an d lower limit in x - axis
            x.domain(series[0].data.map(function (d) {
                return d.date;
            }));

            //var mult = Math.max(1, Math.floor(width / x.domain().length));
            x.rangePoints([0, width], 0.1, 0);
            //console.log("Mult = ",mult,x.domain().length,width)
            //setting the upper an d lower limit in y - axis
            y.domain([
                d3.min(series, function (c) {
                    return d3.min(c.data, function (v) {
                        return v.temperature;
                    });
                }) - 4,
                d3.max(series, function (c) {
                    return d3.max(c.data, function (v) {
                        return v.temperature;
                    });
                }) + 5
            ]);


            var tickInterval = parseInt(x.domain().length / 10);
            var ticks = x.domain().filter(function (d, i) {
                return !(i % tickInterval);
            });

            console.log(ticks.length);

            xAxis.tickValues(ticks);
            yAxis.innerTickSize(-width);




            //Appending x - axis
            svg.append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(0," + height + ")")
                    .call(xAxis)
                    .append("text")
                    .attr("x", (width / 2))
                    .attr("y", 35)
                    .style("text-anchor", "middle")
                    .attr("class","axis-label")
                    .text(obj.xAxis&&obj.xAxis.label?obj.xAxis.label:"");


            //Appending y - axis
            svg.append("g")
                    .attr("class", "y axis")
                    .call(yAxis)
                    .append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", 6)
                    .attr("dy", "-3.71em")
                    .attr("dx", -((height)/2)-margin.top)
                    .style("text-anchor", "middle")
                    .attr("class","axis-label")
                    .text(obj.yAxis&&obj.yAxis.label?obj.yAxis.label:"");


            //Appending line in chart
            svg.selectAll(".city")
                    .data(series)
                    .enter().append("g")
                    .attr("class", "city")
                    .append("path")
                    .attr("class", "line")
                    .attr("d", function (d) {
                        return line(d.data);
                    })
                    .attr("data-legend", function (d) {
                        return d.label
                    })
                    .style("stroke", function (d) {
                        return color(d.label);
                    })
                    .classed("line-hover", false);


            //selecting all the paths
            var path = svg.selectAll("path");

            //For each line appending the circle at each point
            series.forEach(function (data) {
                var visibility = "visible";
                //if the length of the
                if (data.data.length > 270) {
                    visibility = "hidden";
                }
                svg.selectAll("dot")
                        .data(data.data)
                        .enter().append("circle")
                        .attr('class', 'clips')
                        .attr('id', function (d) {
                            return parseInt(x(d.date))
                        })
                        .style('visibility', visibility)
                        .attr("r", 3)
                        .style('fill', color(data.label))
                        .attr("cx", function (d) {
                            return x(d.date);
                        })
                        .attr("cy", function (d) {
                            return y(d.temperature);
                        });

            });


            //Hover functionality
            d3.selectAll(obj.divId).on('mousemove', function () {
                nvtooltip.cleanup();
                var cord = d3.mouse(this);


                if (HoverFlag) {
                    mouseMoveHide = 'visible'
                } else {
                    mouseMoveHide = 'hidden'

                }

                if (cord[1] < margin.top || cord[1] > height || series.length==0 || series[0].data.length==0) {
                    return
                }

                d3.selectAll('circle[class="clips"]')
                        .attr('r', dataLength > 200 ? 0 : 3);
                var flag = true;
                var xpos = parseInt(cord[0] - margin.left);
                while (d3.selectAll("circle[id='" + (xpos) + "']")[0].length == 0) {
                    if (flag) {
                        xpos++
                    } else {
                        xpos--;
                        if(xpos<0)
                        {
                            break;
                        }
                    }
                    if (xpos >= width && flag) {
                        flag = false;
                    }
                }

                var hover = d3.selectAll("circle[id='" + xpos + "']")
                        .attr('r', 6)
                        .style('visibility', mouseMoveHide);
                var data = hover.data();
                nvtooltip.show([cord[0], cord[1]], '<h3>' + moment(data[0].date).format("YYYY-MM-DD") + '</h3>');

            })
                    .on('mouseout', function () {
                        nvtooltip.cleanup();
                        var radius;
                        if (dataLength > 200) {
                            radius = 0
                        } else {
                            radius = 3
                        }
                        d3.selectAll('circle[class="clips"]')
                                .attr('r', radius)
                                .style('visibility', 'visible');
                    });


            //zoming function
            d3.select(obj.divId)
                    .on("mousedown", function () {


                        //remove all the rectangele created before
                        d3.selectAll(obj.divId+" > rect").remove();

                        //assign this toe,
                        var e = this,
                                origin = d3.mouse(e),   // origin is the array containing the location of cursor from where the rectangle is created
                                rect = svg.append("rect").attr("class", "zoom"); //apending the rectangle to the chart
                        d3.select("body").classed("noselect", true);  //disable select
                        console.log(origin)
                        //find the min between the width and and cursor location to prevent the rectangle move out of the chart
                        origin[0] = Math.max(0, Math.min(width, (origin[0] - margin.left)));
                        HoverFlag = false;


                        if (origin[1] < margin.top || origin[1] > height|| series.length==0) {
                            HoverFlag = true;
                            return
                        }
                        //if the mouse is down and mouse is moved than start creating the rectangle
                        d3.select(window)
                                .on("mousemove.zoomRect", function () {
                                    console.log("zooming rectangle changing")
                                    //current location of mouse
                                    var m = d3.mouse(e);
                                    //find the min between the width and and cursor location to prevent the rectangle move out of the chart
                                    m[0] = Math.max(0, Math.min(width, (m[0] - margin.left)));

                                    //asign width and height to the rectangle
                                    rect.attr("x", Math.min(origin[0], m[0]))
                                            .attr("y", margin.top)
                                            .attr("width", Math.abs(m[0] - origin[0]))
                                            .attr("height", height-margin.top);
                                })
                                .on("mouseup.zoomRect", function () {  //function to run mouse is released

                                    d3.select(window).on("mousemove.zoomRect", null).on("mouseup.zoomRect", null);

                                    //allow selection
                                    d3.select("body").classed("noselect", false);
                                    var m = d3.mouse(e);

                                    //the position where the mouse the released
                                    m[0] = Math.max(0, Math.min(width, (m[0] - margin.left)));
                                    console.log("zooming complete");
                                    //check that the origin location on x axis of the mouse should not be eqaul to last
                                    if (m[0] !== origin[0]&&series.length!=0) {

                                        //starting filtering data
                                        cities.forEach(function (d) {

                                            //slicing each line if and only if the length of data > 50 (minimum no of ticks should be present in the graph)
                                            if (d.data.length > 50) {
                                                d.data = d.data.filter(function (a) {
                                                    if (m[0] < origin[0]) {
                                                        return x(a.date) >= m[0] && x(a.date) <= origin[0];
                                                    } else {
                                                        return x(a.date) <= m[0] && x(a.date) >= origin[0];
                                                    }
                                                });
                                            }
                                        });
                                        zoom = false
                                        //calling the chart function to update the graph
                                        chart.plot();
                                    }
                                    HoverFlag = true;
                                    rect.remove();
                                }, true);
                        d3.event.stopPropagation();
                    });


            //When in mouse is over the line than focus the line
            path.on('mouseover', function (d) {
                d.hover = true;
                hover()
            });

            //When in mouse is put the line than focus the line
            path.on('mouseout', function (d) {
                d.hover = false;
                hover()
            });

            //on legend mouse over highlight the respective line
            legend.dispatch.on('legendMouseover', function (d) {
                d.hover = true;
                hover()
            });

            //on legend mouse out set the line to normal
            legend.dispatch.on('legendMouseout', function (d) {
                d.hover = false;
                hover()
            });


            //on legend click toggle line
            legend.dispatch.on('legendClick', function (d) {
                d.disabled = !d.disabled;
                chart.plot();
            });


            function hover() {
                d3.selectAll("path").classed("line-hover", function (d) {
                    return d.hover
                })
            }


        };

        chart.plot();


        window.addEventListener('resize', function () {
            width = $(obj.divId).width() - margin.left - margin.right;
            chart.plot();
        });

        chart.height = function (newHeight) {
            if(newHeight!=height) {
                height = newHeight;
                chart.plot();
            }
        };

        chart.margin = function (_) {
            if(_) {
                margin = _;
                chart.plot();
            }
        };

        return chart;


    }
    var obj
    d3.tsv("data-1.csv", function (error, data) {
        obj={
            data:data,
            divId:"#test",
            title:"Test Graph",
            xAxis:{
                label:"Date"
            },
            yAxis:{
                label:"Number"
            }
        };
        var chart = d3Line(obj);
        console.log(chart)
    })

</script>
